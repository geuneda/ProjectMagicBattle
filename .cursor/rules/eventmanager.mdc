---
description: 
globs: 
alwaysApply: false
---
# Unity EventManager 사용 가이드

## 1. EventManager 개요

EventManager는 Publisher-Subscriber 패턴을 구현한 게임 이벤트 시스템입니다.
- **성능 최적화**: 캐시 배열 사용으로 매번 리스트 복사 연산 방지
- **메모리 효율**: GC 압박 최소화를 위한 구조 설계
- **안전성**: try-catch를 통한 예외 처리

## 2. 기본 사용법

### 2.1 이벤트 구독 (Subscribe)
```csharp
// 컴포넌트에서 이벤트 구독
public class PlayerController : MonoBehaviour
{
    private void Start()
    {
        // 플레이어 사망 이벤트 구독
        EventManager.Subscribe(EnumTypes.GameEventType.PlayerDied, OnPlayerDied);
        
        // 레벨업 이벤트 구독
        EventManager.Subscribe(EnumTypes.GameEventType.PlayerLevelUp, OnPlayerLevelUp);
    }
    
    private void OnPlayerDied(object args)
    {
        Debug.Log("플레이어가 사망했습니다!");
        // 사망 처리 로직
    }
    
    private void OnPlayerLevelUp(object args)
    {
        int newLevel = (int)args;
        Debug.Log($"레벨업! 새로운 레벨: {newLevel}");
    }
}
```

### 2.2 이벤트 발생 (Dispatch)
```csharp
public class Enemy : MonoBehaviour
{
    public void Die()
    {
        // 적 처치 이벤트 발생
        EventManager.Dispatch(EnumTypes.GameEventType.EnemyDefeated, this);
        
        // 경험치 획득 데이터와 함께 이벤트 발생
        var expData = new { amount = 100, enemyType = "Orc" };
        EventManager.Dispatch(EnumTypes.GameEventType.PlayerLevelUp, expData);
    }
}
```

### 2.3 이벤트 구독 해제 (Unsubscribe)
```csharp
public class UIManager : MonoBehaviour
{
    private void OnDestroy()
    {
        // 컴포넌트 삭제 시 이벤트 구독 해제 (메모리 누수 방지)
        EventManager.Unsubscribe(EnumTypes.GameEventType.UIOpened, OnUIOpened);
        EventManager.Unsubscribe(EnumTypes.GameEventType.UIClosed, OnUIClosed);
    }
}
```

## 3. 커서 룰 (사용 가이드라인)

### 3.1 필수 규칙 ⭐

#### 반드시 구독 해제하기
```csharp
// ✅ 올바른 예: OnDestroy에서 구독 해제
public class GameUI : MonoBehaviour
{
    private void Start()
    {
        EventManager.Subscribe(EnumTypes.GameEventType.GameOver, OnGameOver);
    }
    
    private void OnDestroy()
    {
        EventManager.Unsubscribe(EnumTypes.GameEventType.GameOver, OnGameOver);
    }
}

// ❌ 잘못된 예: 구독 해제 없음 (메모리 누수 발생)
public class BadExample : MonoBehaviour
{
    private void Start()
    {
        EventManager.Subscribe(EnumTypes.GameEventType.GameOver, OnGameOver);
        // OnDestroy에서 Unsubscribe 하지 않음!
    }
}
```

#### 이벤트 리스너 메서드 명명 규칙
```csharp
// ✅ 올바른 예: "On" 접두사 사용
private void OnPlayerDied(object args) { }
private void OnSkillUsed(object args) { }
private void OnItemCollected(object args) { }

// ❌ 잘못된 예: 명명 규칙 위반
private void PlayerDiedHandler(object args) { }
private void HandleSkillUsed(object args) { }
```

### 3.2 데이터 전달 패턴

#### 단순 데이터 전달
```csharp
// int, float, string 등 기본 타입
EventManager.Dispatch(EnumTypes.GameEventType.PlayerHealthChanged, 80);
EventManager.Dispatch(EnumTypes.GameEventType.MusicChanged, "boss_theme.mp3");
```

#### 복합 데이터 전달 - Anonymous Object 사용
```csharp
// ✅ 권장: Anonymous Object 사용
var skillData = new { 
    skillType = EnumTypes.SkillType.Attack, 
    damage = 150, 
    cooldown = 3.0f 
};
EventManager.Dispatch(EnumTypes.GameEventType.SkillUsed, skillData);

// 수신 측에서 사용
private void OnSkillUsed(object args)
{
    var skillInfo = args as dynamic;
    Debug.Log($"스킬 사용: {skillInfo.skillType}, 데미지: {skillInfo.damage}");
}
```

#### 복합 데이터 전달 - Custom Class 사용
```csharp
// ✅ 권장: 구조체나 클래스 정의
[System.Serializable]
public struct ItemEventData
{
    public EnumTypes.ItemType itemType;
    public string itemName;
    public int quantity;
    public EnumTypes.ItemRarity rarity;
}

// 사용 예
var itemData = new ItemEventData
{
    itemType = EnumTypes.ItemType.Weapon,
    itemName = "마법검",
    quantity = 1,
    rarity = EnumTypes.ItemRarity.Epic
};
EventManager.Dispatch(EnumTypes.GameEventType.ItemCollected, itemData);
```

### 3.3 성능 최적화 패턴

#### 자주 사용되는 이벤트는 로컬 변수로 캐싱
```csharp
public class HealthSystem : MonoBehaviour
{
    // ✅ 성능 최적화: 자주 사용되는 이벤트 타입을 상수로 정의
    private const EnumTypes.GameEventType HEALTH_CHANGED_EVENT = EnumTypes.GameEventType.PlayerHealthChanged;
    
    public void TakeDamage(int damage)
    {
        currentHealth -= damage;
        
        // 캐싱된 상수 사용
        EventManager.Dispatch(HEALTH_CHANGED_EVENT, currentHealth);
    }
}
```

#### Null 체크 패턴
```csharp
private void OnItemCollected(object args)
{
    // ✅ 안전한 캐스팅 패턴
    if (args is ItemEventData itemData)
    {
        Debug.Log($"아이템 획득: {itemData.itemName}");
    }
    else if (args != null)
    {
        Debug.LogWarning($"예상하지 못한 데이터 타입: {args.GetType()}");
    }
}
```

### 3.4 실제 사용 시나리오

#### 플레이어 시스템
```csharp
public class Player : MonoBehaviour
{
    [SerializeField] private int maxHealth = 100;
    [SerializeField] private int currentHealth;
    
    private void Start()
    {
        currentHealth = maxHealth;
        
        // 생성 이벤트 발생
        EventManager.Dispatch(EnumTypes.GameEventType.PlayerSpawned, this);
    }
    
    public void TakeDamage(int damage)
    {
        currentHealth = Mathf.Max(0, currentHealth - damage);
        
        // 체력 변화 이벤트 발생
        var healthData = new { current = currentHealth, max = maxHealth };
        EventManager.Dispatch(EnumTypes.GameEventType.PlayerHealthChanged, healthData);
        
        if (currentHealth <= 0)
        {
            Die();
        }
    }
    
    private void Die()
    {
        // 사망 이벤트 발생
        EventManager.Dispatch(EnumTypes.GameEventType.PlayerDied, this);
    }
}
```

#### UI 시스템
```csharp
public class HealthBar : MonoBehaviour
{
    [SerializeField] private Slider healthSlider;
    
    private void Start()
    {
        EventManager.Subscribe(EnumTypes.GameEventType.PlayerHealthChanged, OnHealthChanged);
        EventManager.Subscribe(EnumTypes.GameEventType.PlayerSpawned, OnPlayerSpawned);
    }
    
    private void OnDestroy()
    {
        EventManager.Unsubscribe(EnumTypes.GameEventType.PlayerHealthChanged, OnHealthChanged);
        EventManager.Unsubscribe(EnumTypes.GameEventType.PlayerSpawned, OnPlayerSpawned);
    }
    
    private void OnHealthChanged(object args)
    {
        if (args is var healthData && healthData != null)
        {
            var data = healthData as dynamic;
            float healthRatio = (float)data.current / data.max;
            healthSlider.value = healthRatio;
        }
    }
    
    private void OnPlayerSpawned(object args)
    {
        // 플레이어 생성 시 초기 체력 설정
        healthSlider.value = 1.0f;
    }
}
```

### 3.5 주의사항 및 베스트 프랙티스

#### ⚠️ 주의사항
```csharp
// ❌ 잘못된 예: 이벤트 체인으로 인한 무한 루프
private void OnPlayerLevelUp(object args)
{
    // 레벨업 시 또 다른 레벨업 이벤트 발생 - 무한 루프 위험!
    EventManager.Dispatch(EnumTypes.GameEventType.PlayerLevelUp, args);
}

// ❌ 잘못된 예: 과도한 이벤트 발생 (매 프레임)
private void Update()
{
    // Update에서 이벤트 발생은 성능 문제 야기
    EventManager.Dispatch(EnumTypes.GameEventType.PlayerHealthChanged, currentHealth);
}
```

#### ✅ 베스트 프랙티스
```csharp
// ✅ 올바른 예: 조건부 이벤트 발생
private int lastHealth;

private void UpdateHealth(int newHealth)
{
    if (lastHealth != newHealth)  // 변화가 있을 때만 이벤트 발생
    {
        lastHealth = newHealth;
        EventManager.Dispatch(EnumTypes.GameEventType.PlayerHealthChanged, newHealth);
    }
}

// ✅ 올바른 예: 이벤트 데이터 검증
private void OnSkillUsed(object args)
{
    if (args is not SkillEventData skillData)
    {
        Debug.LogError("잘못된 스킬 데이터 형식입니다.");
        return;
    }
    
    // 안전한 스킬 처리 로직
    ProcessSkill(skillData);
}
```

## 4. 확장 가능한 패턴

### 4.1 이벤트 우선순위 시스템 (향후 확장)
```csharp
// 향후 확장 가능한 구조 예시
public class PriorityEventManager
{
    // 우선순위별 이벤트 처리 (현재는 기본 EventManager 사용)
    public static void DispatchHighPriority(EnumTypes.GameEventType type, object args)
    {
        // 즉시 처리가 필요한 이벤트 (예: 플레이어 사망)
        EventManager.Dispatch(type, args);
    }
}
```

### 4.2 이벤트 로깅 시스템
```csharp
public static class EventLogger
{
    public static void LogEvent(EnumTypes.GameEventType eventType, object data = null)
    {
        #if UNITY_EDITOR || DEVELOPMENT_BUILD
        Debug.Log($"[EventManager] {eventType} 이벤트 발생: {data}");
        #endif
    }
}
```

이제 EventManager를 사용할 때 이 가이드를 참고하여 일관성 있고 안전한 이벤트 시스템을 구축할 수 있습니다! 